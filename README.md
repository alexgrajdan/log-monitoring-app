# Log Monitoring Application

This application is a solution to a coding challenge focused on parsing and analyzing log files. The primary goal is to monitor job execution times, identify long-running processes, and report anomalies found in the log data.

## Overview

The application reads a log file (e.g., `log/logs.log`) where each line represents a START or END event for a specific job, identified by a Process ID (PID). It calculates the duration of each job and flags jobs that exceed predefined time thresholds. The application is designed with a modular structure, with core logic encapsulated within the `core_modules` package for better readability and maintainability.

## Features

*   **CSV Log Parsing:** Parses log entries from a CSV-like file format: `HH:MM:SS,Job Description,Status,PID`.
*   **Job Tracking:** Identifies and tracks individual jobs using their PID from their START to END events.
*   **Duration Calculation:** Accurately calculates the duration of each completed job.
*   **Threshold-Based Alerts:**
    *   **Warning:** Generates a warning if a job takes longer than 5 minutes.
    *   **Error:** Generates an error if a job takes longer than 10 minutes.
*   **Anomaly Detection:**
    *   Reports jobs that have an `END` event without a corresponding `START`.
    *   Reports jobs that have a `START` event but no `END` event by the end of the log file.
    *   Reports malformed log lines or lines with invalid status types.
    *   Reports if a job receives a new `START` event while a previous instance with the same PID is still considered active.
    *   Reports `END` events that occur chronologically before their `START` events.
*   **Modular Design:** The codebase is organized into a core package (`core_modules`) for better separation of concerns.

## Project Structure

The project is organized as follows:

```bash
$ tree
.
├── README.md
├── core_modules
│   ├── __init__.py
│   ├── config.py
│   ├── log_parser.py
│   ├── log_processor.py
│   ├── reporter.py
│   └── utils.py
├── design
│   ├── diagram.md
│   └── pseudocode.md
├── log
│   └── logs.log
└── main.py
```
*(Note: `__pycache__/` directories and their contents are typically generated by Python and are usually included in `.gitignore`.)*

## Log File Structure

The application expects the input log file (default: `log/logs.log`) to have entries in the following CSV-like format:

`HH:MM:SS,The job description,STATUS,PID`

Where:
*   `HH:MM:SS`: Timestamp in hours, minutes, and seconds.
*   `The job description`: A string describing the job.
*   `STATUS`: Either "START" or "END" indicating the event type (case-insensitive).
*   `PID`: An integer Process ID associated with the job.

## How to Run

1.  **Prerequisites:**
    *   Python 3 (developed and tested with Python 3.x).
2.  **Clone the Repository (Optional):**
    If you haven't already, clone the repository:
    ```bash
    git clone https://github.com/alexgrajdan/log-monitoring-app.git
    cd log-monitoring-app
    ```
3.  **Ensure Log File:**
    Make sure the `logs.log` file is present in the `log/` subdirectory. This is the default input file as specified in `core_modules/config.py`. You can modify `LOG_FILE_PATH` in `core_modules/config.py` to point to a different file if needed.
4.  **Navigate to Project Root:**
    Ensure your terminal is in the root directory of the project (e.g., `log-monitoring-app/`).
5.  **Execute the Application:**
    Run the application using the following command:
    ```bash
    python3 main.py
    ```

## Output

The application will print a report to the console, detailing:
*   Any **ERROR** messages for jobs exceeding 10 minutes.
*   Any **WARNING** messages for jobs exceeding 5 minutes.
*   Any **ANOMALY** messages (e.g., malformed lines, START without END, END without START, invalid status).
*   A summary message if no reportable issues are found after processing the log file.
*   A message if the log file is empty or contains no processable entries.
*   A message if the log file specified in the configuration is not found.

## Design Documents

The `design/` directory contains:
*   `diagram.md`: A Mermaid diagram illustrating the application's workflow.
*   `pseudocode.md`: Pseudocode that was used as a blueprint for the implementation.